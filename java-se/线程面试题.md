## 一些线程面试题





#### 1. 什么是线程

[维基百科:线程](https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B)

线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。

* 提高了程序的执行吞吐率 	
* 提高了程序的执行效率

#### 2. 线程和进程的区别

* 进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。

  > 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。如果有兴趣深入的话，我建议你们看看《现代操作系统》或者《操作系统的设计与实现》。对就个问题说得比较清楚。

* 线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。每个线程都拥有单独的栈内存用来存储本地数据。
* 进程是资源的分配单位，线程是CPU在进程内切换的单位，线程属于进程

#### 3. 如何创建线程？

* 继承Thread类

  ```java
  class ThreadExample extends Thread {
  
      @Override
      public void run() {
          System.out.print("hi,lvbin");
      }
  }
  ```

* 实现runnable方法

  ```java
  class RunnableExample implements Runnable{
      @Override
      public void run() {
          System.out.print("hi,lvbin");
      }
  }
  ```

* 实现Callable方法

  ```java
  //String为泛型T
  class CallableExample implements Callable<String>{
  
      @Override
      public String call() throws Exception {
          System.out.print("hi,lvbin");
  
          return "lvbin";
      }
  }
  ```

**线程的启动**

```java
ThreadExample t1 = new ThreadExample();
t1.start();


RunnableExample r = new RunnableExample();
Thread t2= new Thread(r);
t2.start();

//Callable扔进FutureTask中，然后启动
CallableExample c = new CallableExample();
FutureTask<String> ft = new FutureTask<>(c);
Thread t3 = new Thread(ft);
t3.start();
//lambda表达式
new Thread(()->print("lvbin")).start();
```



#### 4. 用Runnable还是Thread？

必须是Runnable。实际上更推荐用callable，带返回值和抛出异常

- Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；
- 类可能只要求可执行就行，继承整个 Thread 类开销过大。

#### 5. Runnable和Callable？

Callable带返回值和抛出异常

```java
@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}

@FunctionalInterface
public interface Runnable {
    public abstract void run();
}
```

#### 6. CyclicBarrier 和 CountDownLatch理解和比较？

* CountDownLatch : 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。

  ```java
  CountDownLatch countDownLatch = new CountDownLatch(1);
          Thread t1 = new Thread(() -> {
              try {
                  countDownLatch.await();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              print("t1 start");
          });
          Thread t2 = new Thread(() -> {
              try {
                  countDownLatch.await();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              print("t2 start");
          });
          Thread t3 = new Thread(() -> {
              try {
                  countDownLatch.await();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
              print("t3 start");
          });
          t1.start();
          t2.start();
          t3.start();
          Thread.sleep(3000);
          print("start");
  		//调用countdown方法，使之前调用await方法阻塞的线程全部放开
          countDownLatch.countDown();
          t1.join();
          t2.join();
          t3.join();
  
  ```

* CyclicBarrier : N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。

  ```java
  //每个线程执行await之后阻塞，当3个阻塞后同时开始执行接下来代码
  //CyclicBarrier更像一个水闸, 线程执行就想水流, 在水闸处都会堵住, 等到水满(线程到齐)了, 才开
  //始泄流.
  CyclicBarrier cyclicBarrier = new CyclicBarrier(3, () -> print("gogogo"));
          Thread t1 = new Thread(() -> {
  
              print("t1 start");
              try {
                  cyclicBarrier.await();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              } catch (BrokenBarrierException e) {
                  e.printStackTrace();
              }
              print("t1 after");
  
          });
  
          Thread t2 = new Thread(() -> {
  
              print("t2 start");
              try {
                  Thread.sleep(2000);
                  cyclicBarrier.await();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              } catch (BrokenBarrierException e) {
                  e.printStackTrace();
              }
              print("t2 after");
          });
  
          Thread t3 = new Thread(() -> {
  
              print("t3 start");
              try {
                  cyclicBarrier.await();
              } catch (InterruptedException e) {
                  e.printStackTrace();
              } catch (BrokenBarrierException e) {
                  e.printStackTrace();
              }
              print("t3 after");
          });
  
  
          t1.start();
          t2.start();
          t3.start();
  
          t1.join();
          t2.join();
          t3.join();
  Result:
  t1 start
  t3 start
  t2 start
  gogogo   //当barrier放开后 执行
  t2 after
  t3 after
  t1 after
  ```

* 这样应该就清楚一点了，对于CountDownLatch来说，重点是那个“一个线程”, 是它在等待， 而另外那N的线程在把“某个事情”做完之后可以继续等待，可以终止。而对于CyclicBarrier来说，重点是那N个线程，他们之间任何一个没有完成，所有的线程都必须等待。

* CyclicBarrier可以reset重复使用，countdownlatch不可以。

#### 7. Java内存模型是什么？

[github内存模型](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E5%8D%81java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)

* 主内存和工作内存

  > 处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。
  >
  > 加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。
  >
  > **所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。**
  >
  > **线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成**。

  ![内存模型](pic\内存模型.png)

* 内存间的操作，java定义了8种操作

  * read：把一个变量的值从主内存传输到工作内存中
  * load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中
  * use：把工作内存中一个变量的值传递给执行引擎
  * assign：把一个从执行引擎接收到的值赋给工作内存的变量
  * store：把工作内存的一个变量的值传送到主内存中
  * write：在 store 之后执行，把 store 得到的值放入主内存的变量中
  * lock：作用于主内存的变量
  * unlock

* 内存模型三个特性

  * 原子性

    > Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 J**ava 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行**，即 **load、store、read 和 write** 操作可以不具备原子性。

  * 可见性

    > 可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。

    主要有有三种实现可见性的方式：

    - **volatile**
    - **synchronized**，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。
    - **final**，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。

  * 有序性

    > 在本线程内观察，所有操作都是有序的。**在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序**。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

  * Jvm还规定了先行发生原则，让一个操作无需控制能领先于另一个操作。

    [先行发生原则](https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md#%E5%8D%81java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B) 

    8个原则简述如下

    > ##### 1. 单一线程原则
    >
    > >  Single Thread rule
    >
    > 在一个线程内，在程序前面的操作先行发生于后面的操作。
    >
    > ##### 2. 管程锁定规则
    >
    > >  Monitor Lock Rule
    >
    > 一个 unlock 操作先行发生于后面对同一个锁的 lock 操作
    >
    > ##### 3. volatile 变量规则
    >
    > >  Volatile Variable Rule
    >
    > 对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。
    >
    > ##### 4. 线程启动规则
    >
    > >  Thread Start Rule
    >
    > Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。
    >
    > ##### 5. 线程加入规则
    >
    > > Thread Join Rule
    >
    > Thread 对象的结束先行发生于 join() 方法返回
    >
    > ##### 6. 线程中断规则
    >
    > >  Thread Interruption Rule
    >
    > 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。
    >
    > ##### 7. 对象终结规则
    >
    > >  Finalizer Rule
    >
    > 一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。
    >
    > ##### 8. 传递性
    >
    > >  Transitivity
    >
    > 如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C

#### 8. volatile 变量是什么

* volatile 具有内存可见性的语义。被volatile修饰的变量将会同时对其他线程可见。即该变量的变动将会对所有线程可见。
* 阻止指令重排序 （ volatile 变量规则）

#### 9. 什么是竞态条件？临界区？

当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。下例中add()方法就是一个临界区,它会产生竞态条件。在临界区中使用适当的同步就可以避免竞态条件。

```java
public class Counter {
    protected long count = 0;
    public void add(long value){
        this.count = this.count + value;  
    }
}

```

#### 10. 如何停止一个线程？

* Java并没有立即停止线程的方法，以前有 被废弃

* <**不推荐**>可以在循环中置一个volatile修饰的变量，通过检查这个变量的状态退出循环从而结束线程

* 推荐做法是利用Thread的方法

  ```java
  //将该线程的状态置为 中断，只有当前线程出去阻塞、限期等待或者无限期等待状态才会抛出中断异常，中断线程
  Thread.interrupt()
  ```

  然后再线程循环体中做以下检查

  ```java
  //检查是否调用了当前线程的interrupt方法,如果是则返回true
  if (Thread.currentThread().isInterrupted()) {
    // cleanup and stop execution
    // for example a break in a loop
  }
  ```

#### 11. 一个线程运行时发生异常会怎样？

* checkedException必须被处理才能编译通过，所以忽略

* uncheckedException

  * 如果该异常被捕获或抛出，则程序继续运行。 

  * 没有捕获则会退出线程，JVM会调用Thread. getUncaughtExceptionHandler()方法来寻找线程设置的handler做处理

    例子：

    ```java
    package com.tutorialspoint;
    
    import java.lang.*;
    
    public class ThreadDemo {
    
       public static void main(String[] args) {
    
          Thread t = new Thread(new adminThread());
          t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
    
              //当线程异常退出后会执行
             public void uncaughtException(Thread t, Throwable e) {
                System.out.println(t + " throws exception: " + e);
             }
          });
          // this will call run() function
          t.start();
       }
    }
    
    class adminThread implements Runnable {
    
       public void run() {
          throw new RuntimeException();
       }
    } 
    ```

#### 12.  如何在两个线程间共享数据

共享资源即共享的对象，注意处理后同步问题

#### 13. notify 和 notifyAll区别？

* 字面上，notify唤醒一个等待该资源的线程，而notifyAll唤醒所有等待该资源的线程来竞争资源。

* notifyAll常用，notify没用好容易导致死锁

  >先说两个概念：锁池和等待池
  >
  >- 锁池:假设线程A已经拥有了某个对象(注意:不是类)的锁，而其它的线程想要调用这个对象的某个synchronized方法(或者synchronized块)，由于这些线程在进入对象的synchronized方法之前必须先获得该对象的锁的拥有权，但是该对象的锁目前正被线程A拥有，所以这些线程就进入了该对象的锁池中。
  >- 等待池:假设一个线程A调用了某个对象的wait()方法，线程A就会释放该对象的锁后，进入到了该对象的等待池中
  >
  >> Reference：[java中的锁池和等待池 ](https://link.zhihu.com/?target=http%3A//blog.csdn.net/emailed/article/details/4689220)
  >
  >然后再来说notify和notifyAll的区别
  >
  >-  如果线程调用了对象的 wait()方法，那么线程便会处于该对象的**等待池**中，等待池中的线程**不会去竞争该对象的锁**。
  >- 当有线程调用了对象的 **notifyAll**()方法（唤醒所有 wait 线程）或 **notify**()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。也就是说，调用了notify后只要一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争
  >- 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它**还会留在锁池中**，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。
  >
  >> Reference：[线程间协作：wait、notify、notifyAll ](https://link.zhihu.com/?target=http%3A//wiki.jikexueyuan.com/project/java-concurrency/collaboration-between-threads.html)
  >
  >综上，所谓唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而notify只会唤醒一个线程。



#### 14. ThreadLocal

线程本地存储，即该共享变量可见范围为该线程，这样就解决了线程安全的问题。

```java
/**
*  计算方法执行时间，必须用threadlocal来存储starttime。
*/
@Aspect
public class MethodExecuteTime {
    //threadlocal共享
    private static ThreadLocal<Long> startTime = new ThreadLocal<>();
    
    @Pointcut("@annotation(aop.ExecTime)")
    private void timePointCut(){

    }
    //设置ThreadLocal变量，为thread设置开始时间
    @Before("timePointCut()")
    public void before(){
        startTime.set(System.nanoTime());
    }
    
    @AfterReturning("timePointCut()")
    public void after(JoinPoint joinpoint){
        long exeTime= System.nanoTime()-startTime.get();
        long t = TimeUnit.MILLISECONDS.convert(exeTime,TimeUnit.NANOSECONDS);
        logger.info("方法 {} 执行耗时 {}ms",joinpoint.getSignature().getName(),
                t);
    }
}
```

#### 15. 什么是FutureTask？

FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。

```java
//构造方法
FutureTask(Runnable runnable, V result) 	
FutureTask(Callable<V> callable) 
//封装无返回值的runnable
Future<?> f = new FutureTask<Void>(runnable, null)}
//返回结果，阻塞
public V get() throws InterruptedException, ExecutionException
//用来获取执行结果，如果在指定时间内阻塞，还没获取到结果，就直接返回null
public V get(long timeout, TimeUnit unit)
//线程是否执行完毕
public boolean isDone()
```

#### 16. Java中interrupted 和 isInterruptedd方法的区别？

* 可以在 Thread 对象上调用 isInterrupted()方法来检查任何线程的中断状态。这里需要注意：线程一旦被中断，isInterrupted()方法便会返回 true，而一旦 sleep()方法抛出异常，它将清空中断标志，此时isInterrupted()方法将返回 false。
* 可以使用 Thread.interrupted()方法来检查当前线程的中断状态（并隐式重置为 false）。又由于它是静态方法，因此不能在特定的线程上使用，而只能报告调用它的线程的中断状态，如果线程被中断，而且中断状态尚不清楚，那么，这个方法返回 true。与 isInterrupted()不同，**它将自动重置中断状态为 false，第二次调用 Thread.interrupted()方法，总是返回 false，除非中断了线程**。

#### 17. Java中堆和栈的区别？

* 栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈调用，一个线程中存储的变量对其它线程是不可见的
* 堆是所有线程共享的一片公用内存区域。对象都在堆里创建
* 为了提升效率线程会从堆中弄一个缓存到自己的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值

#### 18. 什么是线程池？

创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程

* Executor

  > Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。
  >
  > 主要有三种 Executor：
  >
  > - CachedThreadPool：一个任务创建一个线程；
  > - FixedThreadPool：所有任务只能使用固定大小的线程；
  > - SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。

  ```java
  public static void main(String[] args) {
      ExecutorService executorService = Executors.newCachedThreadPool();
      for (int i = 0; i < 5; i++) {
          executorService.execute(new MyRunnable());
      }
      executorService.shutdown();
  }
  ```

扩展了解

> 阿里巴巴规范中
>
> 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样
> 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
> 说明： Executors 返回的线程池对象的弊端如下：
> 1） FixedThreadPool 和 SingleThreadPool:
> 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。
> 2） CachedThreadPool 和 ScheduledThreadPool:
> 允许的创建线程数量为 Integer.MAX_VALUE， 可能会创建大量的线程，从而导致 OOM。 

#### 19. 生产者消费者例子？

```java
todo
```

#### 20. 死锁？如何避免？

死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：

- 互斥条件：一个资源每次只能被一个进程使用。
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
- 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系

死锁例子：

```java
todo
```

避免：

todo

#### 21. 怎么检测一个线程是否拥有锁

```java
//Thread类中有一个方法
public static native boolean holdsLock(Object obj);
```